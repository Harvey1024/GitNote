# 2. 进程的描述与控制

## 2.1 前驱图和程序执行

前驱图：有向无循环图。Directed acyclic graph  
用于描述进程之间的先后顺序。  
初始结点 Initial Node: 没有前驱的结点。  
终止结点 Final Node: 没有后继的结点。  
每个结点的重量 Weight：表示结点含有的程序量或程序的执行时间。

### 程序顺序执行

一个应用程序由若干程序段组成，按照某种先后顺序执行。  
程序顺序执行时的特征：

1. 顺序性
2. 封闭性，独占全机资源。
3. 可再现性。

### 程序并发执行

不存在前驱关系的程序可以并发执行。  
并发执行特点：

1. 间断性。并发执行的程序间存在相互制约的关系，存在“执行-暂停-执行”的间断性活动规律
2. 失去封闭性。系统各种资源共享，
3. 不可再现性。由于失去了封闭性，计算结果与并发程序的执行速度有关。

## 2.2 进程的描述

### 进程的定义

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。  
进程实体（进程映像）：由程序段，相关的数据段，和 PCB（进程控制块）组成。  
PCB 进程控制块 Process control block: 为使并发程序能够独立运行，操作系统给进程分配的专门的数据结构。系统利用 PCB 描述进程的基本情况和活动过程，进而进行控制和管理进程。

### 进程的特征

1. 动态性。进程的实质是进程实体的执行过程，是动态的过程。
2. 并发性。多个进程实体共同存在于内存中，在一段时间内同时运行。
3. 独立性。进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位。
4. 异步性。进程是按照异步的方式运行的。按照各自的独立的，不可预知的速度推进。（为实现并发执行结果可再现，配置相应的进程同步机制）

### 进程的基本状态及转换

三种基本状态：

1. 就绪 Ready：分配到除了 CPU 以外的其他所有必要资源
2. 执行 Running：获得 CPU，程序正在执行的状态
3. 阻塞 Block：由于发生某事件暂时无法继续执行的状态

创建状态：创建一个进程的过程。引入创建状态是为了保证进程的调度必须在创建工作结束后进行。  
终止状态：进程的终止：等待操作系统进行最后的善后处理，最后将 PCB 清零，PCB 空间返还系统。

### 挂起操作和进程状态的转换

挂起操作：方便系统和用户观察和分析进程的需要。  
当进程被挂起后，意味着改进程处于静止状态，如果进程正在执行，则暂停执行，如果原本处于就绪状态，则该进程暂时不接受调度。

1. 挂起操作的引入：
   - 终端用户的需要，程序测试
   - 父进程请求，父进程挂起某个子进程，以便考察和修改该进程或协调各子进程
   - 负荷调节，系统挂起一些不重要的进程，保证系统能够正常运行
   - 操作系统的需要，操作系统检查运行中资源使用情况或进行记账
2. 进程状态转换
   - 活动就绪 Readya -> 静止就绪 Readys: 进程不再被调度执行
   - 活动阻塞 Blocka -> 静止阻塞 Blocks: 在进程期望的事件发生时，静止阻塞->活动阻塞
   - 静止就绪 -> 活动就绪：激活后
   - 禁止阻塞 -> 活动阻塞

### 进程管理中的数据结构

进程表又称为进程控制块 PCB

进程控制块 PCB 作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统最重要的记录型数据就够。

PCB 的作用是使一个在多道程序环境下不能独立运行的程序成为一个能够独立运行的基本单位，一个能与其他进程并发执行的进程。

- 作为独立运行的基本单位的标志
- 能实现间断性运行方式
- 提供进程管理所需要的信息
- 提供进程调度所需要的信息
- 实现与其他进程的同步和通信

进程块中的信息：

1. 进程标识符
   - 外部标识符：创建者提供
   - 内部标识符：OS 提供，唯一的数字标识符
2. 处理机状态
   - 由处理机的各种寄存器中的内容组成
   - 1.通用寄存器，2.指令寄存器，3.程序状态字 PSW，4.用户栈指针
3. 进程调度信息
   - 进程状态
   - 进程优先级
   - 进程雕塑所需要的的其他信息，等待时间总和，已执行时间总和
   - 事件，阻塞的原因
4. 进程控制信息
   - 程序和数据的地址
   - 进程同步和通信机制
   - 资料清单
   - 链接指针，所在队列下一个 PCB 的首地址

进程控制块的组织方式

1. 线性方式
2. 链接方式
3. 索引方式

## 2.3 进程控制

### 2.3.1 操作系统内核

OS 内核：紧靠硬件的软件层次中的模块，如与硬件紧密相关的模块（中断处理程序），各种常用设备的驱动程序以及运行频率较高的模块（时钟管理，进程调度，许多模块共用的基本模块)。  
OS 内核主要包含以下两大方面的功能：

1. 支撑功能

- 中断处理
- 时钟管理
- 原语操作

2. 资源管理功能

- 进程管理
- 存储器管理
- 设备管理

### 2.3.2 进程创建

#### 1. 进程的层次结构

父进程可以创建子进程。
子进程可以继承父进程所拥有的资源。

UNIX 系统有进程层次结构。
Windows 所有的进程都有相同的地位，只要知道进程的句柄，就可以控制进程，句柄是可以传递的。

#### 2. 进程图

进程图 Process Graph 是描述进程间的关系的一个有向树。  
父进程：Parent Process  
子进程：Progeny Process

#### 3. 引起创建进程的事件

- 用户登录
- 作业调度
- 提供服务
- 应用请求

### 2.3.3 进程终止

进程终止过程：

1. 根据标识符，检索 PCB，读取进程状态。
2. 如果处于执行状态，立即终止，调度标志为真
3. 如果有子孙进程，终止所有子孙进程
4. 将所有资源归还父进程或系统。
5. 将 PCB 从队列中移出

### 2.3.4 进程的阻塞与唤醒

以下事件会引起进程阻塞或唤醒

1. 共享资源请求失败
2. 等待某操作完成
3. 新数据未到达
4. 等待新任务到达

阻塞过程：  
发生以上事件后，进程调用阻塞原语 block 将自己阻塞。

当阻塞所期待的事件发生时，进程调用唤醒原语 wakeup 将等待该事件的进程唤醒。

### 2.3.5 进程的挂起与激活

## 2.4 进程同步

### 2.4.1 基本概念

进程同步机制主要有硬件同步机制、信号量同步机制、管程机制

进程同步的主要任务是对多个相关进程在执行次序上协调，使并发的进程间按照一定规律共享系统资源，可以很好地合作，使程序执行具有可再现性。

1. 两种形式的制约关系：
   - 间接相互制约关系：  
      对于一些硬件资源，需要系统统一分配资源，不能程序直接使用。
   - 直接相互制约关系：
     如进程 B 执行的条件是 A 进程在缓冲区提供了数据。需要对进程的执行次序进行协调。
2. 临界资源：  
   例如打印机只能一个进程进行打印，其他进程需要等待。进程间采用互斥方式。

3. 临界区 critical section
   每个进程中访问临界资源的那段代码称为临界区 critical section
   为了实现互斥，进程进入临界区前需要检查临界区是否正在被其他进程访问，进入临界区后设置临界区状态，退出临界区后设置状态，剩余的代码部分为剩余区。  
   访问临界资源的循环过程如下：

```
while(True){
    entry section
    critical section
    exit section
    left section
}
```

4. 同步机制需要遵循的规则
   1. 空闲让进
   2. 忙则等待
   3. 有限等待：设置等待时间，避免死等
   4. 让权等待：进程不能进入临界区时需要立即释放处理机

### 2.4.2 硬件同步机制

1. 关中断
2. 利用 Test-and-Set 指令
   ```c++
   boolean TS(boolean *lock) {
       boolean old;
       old = *lock;
       *lock = TRUE;
       return old;
   }
   <!-- 利用TS指令实现的互斥循环进程 -->
   do {
       while TS(&lock);
       critical section;
       lock = FALSE;
       remainder section;
   } while(TRUE);
   ```
3. 利用 Swap 指令实现进程互斥

   ```void swap(boolean *a, boolean *b) {
       boolean temp;
       temp = *a;
       *a = *b;
       *b = temp;
   }
   <!-- 实现进程互斥的程序 -->
   do {
       key = TRUE;
       do{
           swap(&lock, &key);
       } while( key != FALSE);
       critical section;
       lock = FALSE;
       remainder section;
   } while (TRUE);

   上述方法当lock为TRUE时， 在while循环里一直不停测试，处于忙等 状态，浪费处理机时间
   ```

### 2.4.3 信号量机制 Semaphores
1. 整型信号量  
    一个用于表示资源数目的整型量S, 仅能通过两个标准的原子操作wait(S)和signal(S)访问。这两个操作成为P,V操作
    原子操作是执行时不可中断的。wait操作时当S<=0时需要不断测试，直到S>0为止，处于忙等状态
2. 记录型信号量  
    除了记录资源数目的整型量value外，还有一个进程链表指针，链接所有等待的进程  
    wait(semaphore *S) value--, 当资源数value<0时，说明资源分配完毕，进程调用block原语进行自我阻塞。并插入到进程链表中。  
    signal(semaphore *S) value++, 当资源数value<=0时，说明还有进程在等待，调用wakeup原语唤醒链表的第一个等待的进程。
3. AND型信号量  
    当进程A,B都需要两个共享资源D,E时，当A:wait(D); B:wait(E); A:wait(E); B: wait(D); 此时发生死锁。  
    为避免死锁，将进行运行所需的资源一次性全部分配给进行，待进程使用完再一起释放。如果有一个资源不能分配，则其他资源也不分配给他。  
    wait(S1, S2, ... Sn); signal(S1, S2, ... Sn);
4. 信号量集
    为了确保系统安全，当所申请的资源数量低于某一下限时，不予分配。  
    wait(S1, t1, d1, ... Sn, tn, dn) ti是资源的下限, di是请求资源数。
### 2.4.4 信号量的应用
1. 利用信号量实现进程互斥  
    设置mutex为互斥信号量，初值为0，取值范围为(-1, 0, 1); mutex = 1表示两个进程都没有进入临界区，mutex = 0表示有一个进程在临界区运行，  
    mutex = -1表示有一个进程在临界区运行，另一个在阻塞队列，需要在临界区运行的进程退出时唤醒。
2. 利用信号量实现前驱关系  
    进程P2运行需要P1先完成，则S1是P1的语句，S2是P2的语句，则可以设置信号量s, 初值为0，P1(){S1; signal(s)}; P2(){wait(s); S2};  
    这样s=0时P2阻塞，当P1运行完后s=1, P2才能执行。
### 2.4.5 管程机制 Monitors,
使用信号量机制，进行需要自备同步操作wait(S),signal(S), 使大量同步操作分散在各进程中，给系统管理带来麻烦，容易导致死锁。
## 2.5 经典进程同步问题

## 2.6 进程通信

### 2.6.1 进行通信类型

1. 共享存储器系统 Shared-Memory System
2. 管道通信系统 Pipe：  
   管道是用于连接一个读进程和写进程，以实现通信的一个文件，称为 pipe 文件。
3. 消息传递系统 Message passing system  
   使用格式化的消息为单位，将信息封装在消息中，利用操作系统的通信命令，在进程间进行消息传递。不借助任何共享存储区或数据结构。
4. 客户机-服务器系统 Client-Server System
   - Socket 套接字：
     - 基于文件型
     - 基于网络型
   - Remote Procedure call 远程过程调用和远程方法调用：

## 2.7 线程

线程是为了使过个程序能够实现并发执行，同时将又尽量减少系统的开销。  
不把作为调度和分派的基本单位也同时只作为拥有资源单位，做到轻装上阵  
对于拥有资源的单位，减少频繁的切换。

### 线程和进程的区别

1. 调度的基本单位  
   传统 OS，进程是能独立运行的基本单位，调度时需要上下文切换，开销大。  
   引入线程的 OS，线程是能独立运行的基本单位，调度时仅保存和设置少量寄存器内容。
2. 并发性  
   进程内的线程可以并发，能够提供系统资源利用率和系统的吞吐量
3. 拥有资源  
   线程本身不拥有系统资源，仅有一点必不可少的，能保证独立运行的资源如 TCB，程序计数器，局部变量，状态参数，返回地址等  
   线程能共享该进程的所有资源

### 2.7.2 线程的状态和线程控制块

1. 线程的状态：
   - 执行状态
   - 就绪状态
   - 阻塞状态
2. 线程控制块 TCB
   - 线程标识符
   - 寄存器：程序计数器，状态寄存器，通用寄存器
   - 线程运行状态
   - 优先级
   - 线程专有存储区
   - 信号屏蔽
   - 堆栈指针

## 2.8 线程的实现

1. 内核支持 KST kernel supported threads
2. 用户级线程 ULT user level threads
3. 组合方式
