# 5. 搜索法
## 5.1 穷举搜索
## 5.2 深度优化搜索
## 5.3 回溯法

#### 4后问题：   
在4x4的方格棋盘上放置4个皇后，使没有两个皇后在同一列，同一行，以及45度方向，有多少种方法？   
解是4维向量如<2,4,1,3>表示在每一列的位置   
搜索空间：4叉树   
<img src='./img/Quadtree.jpg' width = '350'>   
每个节点有4个儿子，分别代表1,2,3,4列位置，判断是否满足条件，不满足开始回到上一个节点继续循环。

#### 0-1背包问题   
<img src = './img/knapsank.jpg' width = '350'>  

父节点表示每个物品，子节点1,0表示选择，或者不选择，父节点依次是物品。   
#### 货郎问题
有n个城市，已知任意两个城市之间的距离，求每个城市恰好一次的最短路径。

搜索空间: 排列树
从第一个城市开始，儿子是剩余的城市，直到最后一个城市。

#### 回溯算法的基本思想
  1. 适用：求解搜索问题和优化问题
  2. 搜索空间：树，节点对应部分解向量，可行解在树叶上
  3. 搜索过程：采用系统的方法隐含遍历搜索树
  4. 搜索策略：深度优先，宽度优先，函数优先，宽深优先
  5. 结点分支判定条件：满足约束条件-分支扩张向量，不满足-回溯到该结点的父节点
  6. 结点状态：动态生成。白结点-尚未访问，灰结点-正在访问该结点为根的子树，黑结点-该结点为根的子树遍历完成。
  7. 存储：当前路径

回溯算法的适用条件：   
多米诺性质   
P(x1,x2...xk+1)->P((x1,x2...xk) 0<k<n
k维向量不满足约束条件，扩张向量到k+1维仍不满足，可以回溯。
#### 回溯算法实现

递归实现
```c
算法 ReBack(k)
if k>n then <x1,x2,...xn>是解
else while S[k] 非空 do
  x[k] = min(S[k])
  S[k] = S[k]-{x[k]}
  计算 S[k+1]
  ReBack(k+1)

算法 ReBacktrack(n)
输入n
输出： 所有解
for k=[1~n] 计算X[k], S[k]=X[k]
Reback(1)
```
迭代实现
```c
迭代算法 Backtrack
输入 n
输出 所有解
1. 对于i=[1~n] 求解X[i] //初始值
2. k=1
3. 计算 S[k]
4. while S[k]非空 do //满足约束，分支搜索
    x[k] = min(S[k]); S[k] = S[k]-{x[k]}
    if k<n then 
      k = k+1
    else
      [x[1],x[2],...,x[n]]是解
5. if k>1 then k = k-1; goto 4 //回溯
```
## 5.4 宽度优先搜索
## 5.5 分支限界法