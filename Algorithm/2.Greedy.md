# 2. 贪心算法

## 2.1 概述

### 2.1.1 贪心算法基本思想

1. 贪心法在每个阶段面临选择时都做出对眼前来讲最有利的选择，不考虑对未来的不良影响
2. 每个阶段的抉择一旦做出，就不可更改，不允许回溯
3. 贪心法时根据贪心策略逐步构造问题的解
4. 贪心法具有高效性和不稳定性（获得的解不一定是最优解，但一定是最优解的近似解）

### 2.1.2 贪心法的基本要素

采用贪心法的问题一般具有两个重要的性质

1. 最优子结构性质:
   当一个问题的最优解一定包含其子问题的最优解时，该问题具有最优子结构性质
2. 贪心选择性质:
   问题的整体最优解可以通过一系列局部最优的选择获得

### 2.1.3 贪心算法解题步骤及算法设计模式

贪心法求解问题步骤：

1. 分解：将问题分解为若干个相互独立地阶段
2. 解决：对每个阶段根据贪心策略进行贪心选择，求出局部的最优解
3. 合并：将各阶段的解合并为原问题的一个可行解

算法设计模式：

```c
Greedy(A,n){
  solution = Null
  for(i=0; i<n; i++)
    solution = union(solution,x);
  return solution
}

```

## 2.2 会场安排问题

输入：S = {1, 2, … , n}为 n 项活动的集合， si , fi 分别为活动 i 的开始和结束时间. </br>
活动 i 与 j 相容：si ≥fj 或 sj ≥f </br>
求：最大的两两相容的活动集 A </br>

### 贪心策略

每次从剩下未安排的会议中选择具有最早时间结束且不会与已安排会议重叠的会议来安排，这样下一个会议尽早开始

## 2.3 单源最短路径问题

给定一个有向带权图 G=(V,E,W)，每条边 e=<i,j>的权 w(e)都是非负实数，另外给定 V 中的一个顶点，称为源点 s,求解从源点到其他所有顶点的最短路径长度。

### Dijkstra 算法

顶点集合 V 被划分成两部分，S 和 V-S，S 内的顶点 u 距离源点 s 的最短路径已经找到，

从 s 到 u 相对于 S 的最短路径：从 s 到 u 且仅经过 S 中顶点的最短路径

dist [u]：从 s 到 u 相对 S 最短路径的长度

short [u]：从 s 到 u 的最短路径的长度

dist [u] ≥ short[u] 相对长度大于等于全局最短长度

通过计算相对长度，不断扩充 S 集合，相对长度逐渐改善，最后改善到和全局最短长度一致。
（通过局部最短，逼近全局最短）

#### 算法设计思想

输入：有向图 G = (V, E, W ),
V = { 1, 2, … , n }，s = 1
输出：从 s 到每个顶点的最短路径

1. 初始 S={1}
2. 对于 i∈V− S，计算 1 到 i 的相对 S 的最短路，长度 dist [i]
3. 选择 V− S 中 dist 值最小的 j，将 j 加入 S，修改 V− S 中顶点的 dist 值.
4. 继续上述过程，直到 S=V 为止.

#### Dijkstra 算法伪码

```c
1. S<-{s}
2. dist[s]<-0
3. for i in V-{s} do
4.    dist[i]<-w(s,i) //如果s到i没边，则等于infty
5. while V-S != empty do
6.    从V-S取相对S的最短路径顶点j
7.    S<-S 并 {j}
8.    for i 属于 V-S do
9.        if dist[j]+w(j,i)<dist[i]
10.       then dist[i] <-dist[j]+w(j,i)
```

## 2.4 哈夫曼编码

二元前缀码：用 0-1 字符串作为代码表示字符，要求任何字符的代码都不能作为其他字符代码的前缀。

前缀码的二叉树表示：0-左子树，1-右子树，码对应一片树叶，最大位数为树深

平均传输位数：B=sum(f(xi)d(xi))

f(xi): xi 字符的频率，d(xi)深度

哈夫曼树算法伪码

```c
算法 Huffman(C)
输入： C={x1,x2,...,xn},f(xi),i=1,2,...n
输出： Q  //队列
1. n<-|C|
2. Q<-C //频率递增队列Q
3. for i<-1 to n-1 do
4.    z<-Allocate-Node()  //生成结点z
5.    z.left<-min of Q
6.    z.right<-min of Q>
7.    f(z)<-f(x)+f(y)
8.    Insert(Q,z)
```

每次选取队列中最小的组成一个树，插入到队列中，父节点的值为两个子节点之和。
循环整个步骤，直到完整的树生成。

## 2.5 最小生成树

对于一个无向连通带权图 G=(V,E,W), 其中 w(e)中 w(e)∈W 是边 e 的权，G 的一棵生成树 T 是包含了 G 的所有顶点的树, 树中各边的权之和 W(T) 称为树的权，具有最小权的生成树称为 G 的最小生成树.

### 2.5.1 Prim 算法

集合 V={1,2,...,n}
初始 S={1}
选择连接 S 集合和 V-S 集合的最短边 e={i,j},将 e 加入到树 T，j 加入到 S，循环执行，指导 S=V 为止。

### 2.5.2 Kruskal 算法

按照长度从小到大对边排序
依次考察当前最短边 e, 如果 e 与 T 的边不构成回路，则把 e 加入树 T，否则跳过 e，直到选择了 n-1 条边为止
