# 8. Spring2
## 8.1 Spring概述
Spring采用了控制反转IoC和AOP面向切面编程技术。
Spring是轻量级的框架。

1. IOC容器：  
    依赖的对象是在程序运行期间由容器创建和销毁，容器控制依赖对象的生命周期，称为控制反转，它使对象之间实现了松耦合。  
2. AOP实现  
    面向切面编程AOP可以将程序的业务代码和系统服务代码（如事务管理，日志记录）分离开，在业务逻辑完全不知道的情况下为其提供系统服务。这样业务逻辑只需要负责和业务处理相关的操作，不需要关心系统服务问题。
## 8.2 IOC

## 8.3 AOP
一个系统中各功能那个模块是相互并列的形式，各功能模块都需要日志服务，事务服务等，通过将这些共用的服务分离出来，进而在改变这些行为的时候不影响业务逻辑的代码。

<img src="img/1605797501775.png" width="40%">

### 8.3.1 AOP术语
1. 关注点 concern: 与所关注业务无关的公共服务
2. 连接点 join point：程序执行过程中，需要添加关注点功能的点。
3. 切面 aspect： 将各个业务对象之间的关注点收集起来，设计成独立，可重用，职责清楚的对象，称为切面
4. 通知 advice：切面在程序运行到某个连接点时所触发的动作
5. 目标对象 target object：一个通知被应用的对象或目标
6. 织入 weaving：把切面连接到目标对象上的过程
7. 切入点 pointcut：匹配连接点的断言。

### 8.3.2 AOP原理
AOP使用了代理模式
1. 静态代理  
```java
//userManager.java 数据库访问接口
public interface UserManager {
    public void addUser(String username, String password);
}
//UserManagerImpl.java 数据库访问实现类
public class UserManagerImpl implements UserManager {
    @Override
    public void addUser(String username, String password){
        System.out.println("user added");
    }
}
//UserManagerImplProxy.java 代理类
public class UserManagerImplProxy implements UserManager {
    private UserManager userManager;
    public UserManagerImplProxy(UserManager userManager) {
        this.userManager = user.Manager;
    }
    @Override
    public void addUser(String username, String password) {
        System.out.println("addUser start");
        userManager.addUser(username, password);
    }
}
//Test.java 测试类
public class Test {
    public static void main(String[] args) {
        UserManager userMgr = new UserManagerImpl();
        UserManagerImplProxy proxy = new UserManagerImplProxy(userMgr);
        proxy.addUser("admin","123");
    }
}
```
2. 动态代理  
    静态代理不能实现切面类和代理类的分离，代理类需要对每个方法添加自己的逻辑。  
    Spring AOP框架对AOP代理类的处理方法：如果目标对象实现了接口，Spring AOP将会采用JDK动态代理来生成AOP代理类，如果目标对象没有实现接口，则无法使用JDK动态代理，则采用CGLib生成AOP代理类。  
    与静态代理不同，动态代理的代理类由JDK提供

使用java.lang.reflect.proxy类创建动态代理类实例
```java 
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interface, InvocationHander h) throws IllegalArgumentException
```
InvocationHander 指派方法调用的调用处理程序

```java
//创建代理对象的调用处理程序（拦截程序）
//TransactionHander.java
public class TransactionHander implements InvocationHander {
    private Object target;
    //绑定被代理对象并返回代理类
    public Object bind(Object target) {
        this.target = target;
        return Proxy.newProxyInstance(target.getClass().getClassLoader, target.getClass().getInterfaces(), this);
    }
    //通过回调方法Invoke()，在执行代理类的方法的时候，会加上日志操作。实现切面类和代理类分离。
    //这样给新的实现类加上日志操作就不用重写代理类了。
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Trowable {
        Object result = null;
        System.out.println("begin");
        result = method.invoke(target, args);
        System.out.prinln("end");
        return result;
    }
}
//TestJdkProxy.java
public classs TestJdkProxy {
    public static void main (String[] args) {
        TransactionHander hander = new TransactionHander();
        UserManager proxy = (UserManager)hander.bind(new UserManagerImpl());
        proxy.addUser("admin","123");
    }
}
```
3. CGLib代理  
JDK动态代理的限制是对象必须实现一个或多个接口。如果类没有接口，则使用CGLib(Code Generation Library)实现动态代理。
```java
//UserManagerImpl.java 没有接口
public class UserManagerImpl {
    public void addUser(String username, String password){
        System.out.println("user added");
    }
}

//TransactionInterceptor.java 拦截程序
public class TransactionInterceptor implements MethodInterceptor {
    private Object target;
    public Object bind(Object target) {
        this.target target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSupperclass(this.target.getClass());
        enhancer.setCallback(this);
        return enhancer.create();   //产生动态代理类
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Trowable {
        Object result;
        System.out.println("begin");
        result. = proxy.invokeSuper(obj, args); //类似JDK的invoke()方法
        System.out.println("send");
        return result
    }
}
```
## 8.4 AOP框架
