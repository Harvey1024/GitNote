# 4. 动态规划
## 4.1 概述
### 动态规划基本思想

动态规划的实质是分治思想和解决冗余
贪心算法当前选择依赖已做出的选择，不依赖未做出的选择
分治算法各个子问题是独立的，不包含公共的子问题。

动态规划算法求解的问题的子问题往往不是相互独立的。
适用条件：问题需要满足优化原则，即：一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列。

### 动态规划求解步骤

1. 分析最优解的性质
2. 递归定义最优值
3. 自底向上的方式计算最优值，并记录相关信息
4. 根据计算最优值时得到的信息，构造出最优解

### 动态规划基本要素

1. 最优子结构性质
2. 子问题重叠性质
3. 自底向上的求解方法

## 4.2 最短路径问题
问题：
输入：起点集合 { S1, S2, ..., Sn } ，
      终点集合{T1, T2, ... , Tm}，
      中间结点集，
      边集 E，对于任意边 e 有长度
输出：一条从起点到终点的最短路
<img src="./img/ShortestPath.jpg" width="350">

## 4.3 矩阵连乘问题
设 A1, A2 , … , An 为矩阵序列，
Ai 为 Pi-1 x Pi 阶矩阵，i = 1, 2, ... , n. 
试确定矩阵的乘法顺序，使得元素相乘的总次数最少.
递推方程：
if i=j
      m[i,j] = 0
if i<j
      m[i,j]=min(m[i,k]+m[k+1,j]+P[i-1]P[k]P[j])

Ai...Ak = P[i-1]P[k]
动态规划算法
```c
算法 MatrixChain(P,n)
1. 令所有的m[i,j]=0
2. for r = 2 to n do
3.    for i = 1 to n-r+1 do
4.          j = i+r-1
5.          m[i,j] = m[i,j-1]+P[i-1]*P[j-1]*P[j]    // 先生成第一个结果，否则下面的判断if t<m[i,j] 出错
6.          s[i,j] = i
7.          for k = i to j-1 do     //遍历k，找到最小的位置
8.                t = m[i,k] + m[k+1,j] + P[i-1]*P[k]*P[i]
9.                if t<m[i,j]
10.               then m[i,j] = t   //更新解
11.                    s[i,j] = k
```
时间复杂度O(n^3)

## 4.4最长公共子序列问题


## 4.5 加工顺序问题
## 4.6 0-1背包问题
一个旅行者随身携带一个背包. 可以放入背包的物品有n 种, 每种物品的重量和价值分别为 wi , vi .    
如果背包的最大重量限制是 b, 每种物品可以放多个. 怎样选择放入背包的物品以使得背包的价值最大 ?    
不妨设上述 wi , vi , b 都是正整数.
#### 约束条件   
      sum(wi*xi)<=b   
      xi in [0,1]   
#### 目标函数   
      max(sum(wi*vi)) 

令C[i][j]表示子问题sum(wk*xk,k=[1~i])<=j,装入前i种物品总重量小于j时的最大价值。   

### 优化函数的递推方程   

      C[i][j] = C[i-1][j]     if j<wi   //总重量限制j比第i个物品重量小时，不装物品i
              = max(C[i-1][j],C[i-1][j-wi]+vi)  if j>=wi   // 能装物品i时，最大价值取装和不装i的最大值 
 
### 判断函数   

判断第i个物品是否要装入   

xi = 0, j = j when C[i][j]=C[i-1][j] 装前i种物品和装前i-1种物品，重量限制j时的最大价值相等，不装i   
xi = 1, j = j-wi when C[i][j]>C[i-1][j]

### 算法设计

```c
算法 Knapsack(P,n)
输入：物品重量w[n],物品价值v[n]
输出: 物品是否放入背包x[n]
1. C
2. 
3. 
4. 
5. 

```
## 4.7 最优二叉查找树
