# 9. 面向对象程序设计
## 1. 面向对象基本概念
### 1. 对象
#### 1. 对象的定义
- 对象是具相同状态的一组操作的集合
- 对象是对问题域㕜某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与他的交互能力
- 对象::<ID,MS,DS,MI>, 其中ID：对象的标识或名字，MS：对象中的操作集合，DS：对象的数据结构，MI：对象受理的消息名集合
#### 2. 对象的特点
- 以数据为中心
- 对象是主动的
- 本质上具有并行性
- 模块独立性好
### 2. 类class
类是具有相同数据结构和相同操作的一组相似对象的定义。  
类是支持继承的抽象数据类型，队形是类的实例

### 3. 实例instance
实例是有某个特定的类所描述的一个具体的对象

### 4. 消息message
消息是要求对某个对象执行在定义它的那个类中所定义的某个操作的规格说明。  
如MyCircle.Show(GREEN),MyCircle是接受消息的对象的名字，Show是消息选择符，GREEN是消息的变元，当MyCircle接收到这个消息的时候执行相关操作。

### 5. 方法Method
如Circle类的Show(int color)的函数定义的代码实现

### 6. 属性 attribute
属性就是类中定义的数据

### 7. 封装 encapsulation
对象具有封装性的条件如下：
1. 有一个清晰的边界（私有数据）
2. 有确定的接口/协议
3. 受保护的内部实现

### 8. 继承 inheritance
继承是指能够直接获得已有的性质和特征，不必重复定义他们

### 多态性 polymorphism
子类的对象可以像父类那样使用

### 重载 overloading
函数重载：同一作用域内若干个参数特征不同的函数可以使用相同的函数名
运算符重载：同一运算符可以作用于不同类型的操作数上

## 2. 对象模型

UML同意建模语言
### 2.1 类图
类：
```
-------
| 类名 |
|------|
| 属性 |
|------|
| 服务 |
-------
```
定义属性：  
可见性 属性名：类型名 = 初值{性质串}

前缀符号 
``` 
+：public
-：private
#: protected
```
如 - operater: String = "Mike"

定义服务：  
可见性 操作名（参数表）：返回值类型{性质串}
### 2.2 关系
1. 关联：
    表示两个类之间存在某种语意上的联系，如作家使用电脑
    - 普通关联：存在连接关系就是普通关联，用实线加实心三角箭头表示  
    在箭头两端写上重数multiplicity表示多少个对象与多少个另一个对象链接  
        ```0··1``` 0到1个对象  
        ```0··*或*```0到多个对象
        ```1+或1··*```  
        ```1···15```  
2. 聚集/聚合
是关联的特例，表示类与类之间的关系是整体与部分的关系

    - 共享聚集：部分方的对象可以参与多个整体方对象的构成  
        实线+空性菱形表示
    - 组合聚集：部分完全隶属于整体，整体消失，则部分也随之消失  
        实线+实心性菱形表示
3. 泛化
继承关系，是通用元素和具体元素之间的一种分类关系
实线+空心箭头z
    - 普通泛化：
    - 受限泛化：给泛化关系附加约束条件（多重，不相交，完全，不完全）
4. 依赖和细化
    - 依赖：一个模型元素是独立的，一个是不独立的，不独立的依赖于独立的模型元素。  
        如：一个类使用另一个类的对象作为操作参数或数据成员，一个类向另一个类发送消息  
        虚线+实心箭头
    - 细化：抽象层次的不同，B是A的基础上的细化   
        虚线+空心箭头


![1594306728535.png](img\1594306728535.png)


## 3. 动态模型
动态模型是基于事件共享互相关联的一组状态图的集合  

状态图用来描述对象的状态、触发状态转换的事件以及对象的行为。
### 3.1 状态
状态：对象属性值得一种抽象。    
是任何可以被观察到的系统行为模式，状态规定了系统归队事件的响应方式。  
状态图中定义的状态有：
    - 初态
    - 中间状态
    - 终态

### 3.2 事件  
事件：各对象之间的相互触发形成了一系列的状态变化，一个触发行为称为一个事件。  

### 3.3 状态图
- 初态：实心圆
- 终态：同心圆,内圆实心
- 中间状态：圆角矩形，分为上中下三部分，分别是转台名称，状态变量，活动表
- 活动表：语法格式：事件名（参数表）/动作表达式
- 状态之间连线上写事件表达式，事件表达式格式：事件说明[守卫条件]/动作表达式
- 守卫条件是布尔表达式，当事件说明及守卫条件同时满足是，触发状态转换。

## 4. 功能模型
功能模型指明了系统应该做什么，直接反应了用户对目标系统的需求。  
用例图用来表达功能模型
### 4.1 用例图
用例图包含系统、行为者、用例及用例之间的关系
1. 系统：提供用例的黑盒，方框代表边界。
2. 用例：椭圆表示，是可以被行为者感受到的，系统的一个完整的功能。  
    用例的实例是系统的一种实际使用方式，称为脚本。
3. 行为者：与系统交互的人或其他系统
4. 用例之间的关系：拓展关系，使用关系

## 5. 面向对象设计原则
### 5.1 设计需要原则
糟糕的设计存在以下问题：  
1. 僵硬性Rigidity，难以拓展
2. 脆弱性Fragility, 难以修改
3. 牢固性Immobility，无法分解成可移植的组件
4. 粘滞性Viscosity，修改设计代价高昂，开发环境迟钝低效。
5. 不必要的复杂性，包含当前没用的组成部分
6. 不必要的重复Nedless repetition, 包含重复的结构
7. 晦涩性Opacity，不透明，难以理解设计意图

### 5.2 Liskov替换原则 Liskov Subsititution principle, LSP
若对每个类型S的对象o1, 都存在一个类型T的对象o2，是的在所有针对T编写的程序P中，用o1替换o2后，程序P的行为不变，则S是T的子类型。  

子类型必须能够替换他们的基类型。  
子类型不能添加任何基类型没有的附加约束，否则，基类型和子类型将会不能替换。  
为了实现LSP，基类尽量提供尽量少的必须行为，且不对这些行为进行任何实现。基类通常是抽象类。  
只要有可能，不要从具体类继承，而应该从抽象类继承，或由接口实现。
### 5.3 开放-封闭原则 the open-close principle, OCP
模块应该既是开放的，有是封闭的。  
- 模块对扩展是开放的：模块的行为是可以扩展的。
- 模块对修改是封闭的。

实现OCP的核心思想是对抽象编程，而不对具体编程。  
让类依赖固定的抽象，所以对修改是封闭的。通过继承和多态实现对抽象体的继承，通过覆写实现扩展。
### 5.4 单一职责原则 The Sigle Responsibility Priciple, SRP
内聚性是一个模块的组成元素之间的的相关性。  
模块设计应遵循高内内聚的设计原则，其中功能内聚是内聚度最高的一种内聚形式，是指模块内所有元素共同完成一个功能，缺一不可，模块不能再被分割。  
单一职责原则就是实现高内聚。
### 5.5 接口隔离原则(The Interface Segregation Principle, ISP)
接口设计也应该是内聚的，职责单一的。
ISP的目的是为不同角色提供宽窄不一的接口，以应对不同的客户端。  
ISP使接口的职责更加明确，有利于系统的维护。将接口隔离出来，有利于降低设计成本。

### 5.6 依赖倒置原则
传统自顶向下，自低向上的编程思想存在高层业务逻辑过分依赖底层模块，难以复用，底层的修改直接影响到上层的各类应用。  
DIP基本思路是使高层模块不再依赖底层模块。
- 高层模块不应该依赖于底层模块，两者都应该依赖于抽象。
- 抽象不应该依赖于细节，细节应该依赖于抽象。

抽象发生改变的频率低，变更影响更小。  
在高层业务逻辑层和实现层之间增加抽象层，他们都依赖抽象层。  
抽象层应该由客户（高层模块）来定义，因此当底层实现逻辑变化时不会影响高层模块。  
DIP的依赖止于抽象思想可以引出如下规则：
- 任何变量都不应该持有一个指向具体类的指针或引用。
- 任何类都不应该从具体类派生（止于抽象，来自具体）
- 任何方法都不应该修改它的任何基类中的、已经实现的方法。