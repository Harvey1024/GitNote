# 3. Tree

## 3.1 定义

树是 n(n>0) 个结点构成的有限集合，当 n=0 时为空树，对于任意一个非空树，都有以下性质

1. 树中只有一个称为树根 root 的特殊节点，用 r 表示
2. 其余结点可以划分为 m 个不相交的子集 T1, T2, ... Tm, 任何子集 Ti(i 属于[1,m])也是一个树成为根节点的子树 subTree, 每个子树的根结点都与 r 有一条相链接的便，r 是这些子树根结点的父结点 parent

基本术语

1. 结点的度 degree，是子树的个数
2. 树的度，所有结点中最大的度
3. 叶结点 leaf，度为 0 的结点
4. 父节点 parent，具有子树的结点是其子树的根节点的父节点
5. 子节点 child， 某个结点，其子树的根结点是它的子节点
6. 兄弟结点 sibling， 具有相同父结点的各结点彼此是兄弟结点
7. 祖先结点 ancestor, 沿树根到某一结点路径上的所有结点是这个结点的祖先结点
8. 子孙结点 descendant， 某结点的子树中所有的结点是这个结点的子孙
9. 结点的层次 level, 根节点在第一层，其他任意一结点的层数是其父结点的层数+1
10. 树的深度 depth, 所有结点中的最大层次
11. 分支，树中两相邻结点的连边成为一个分支
12. 路径和路径长度，从结点 n1 到 nk 的路径被定义为 n1, n2, ... nk, 路径长度是这条路径上边的个数

## 3.2 二叉树 BinTree

二叉树由根节点和左子树和右子树组成

### 3.2.1 二叉树的遍历

1. 中序遍历：对任意结点访问是在遍历完左子树后进行的

- 中序遍历其左子树
- 访问根节点
- 中序遍历其右子树

```c++
void InorderTraversal(BinTree BT){
  if(BT) {
    InorderTraversal(BT.Left);
    print("%d", BT.Data);
    IorderTraversal(BT.Right);
  }
}
```

2. 先序遍历

- 访问根节点
- 先序遍历其左子树
- 先序遍历其右子树

```c++
void PreorderTraversal(BinTree BT){
  if(BT) {
    print("%d", BT.Data);
    PreorderTraversal(BT.Left);
    PrerderTraversal(BT.Right);
  }
}
```

3. 后续遍历

- 后续遍历其左子树
- 后续遍历其右子树
- 访问根结点

```c++
void PostorderTraversal(BinTree BT){
  if(BT) {
    PostorderTraversal(BT.Left);
    PostrderTraversal(BT.Right);
    print("%d", BT.Data);
  }
}
```

4. 非递归遍历

```c++
void InorderTraversal(BinTree BT){
  BinTree T;
  Stack S = CreateStacck();
  T = BT;
  while( T || !IsEmpty(S)) {
    while(T) {
      S.push(T);
      T = T.left;
    }
    T = S.pop();
    printf("%d", T.data);
    T = T.right;
  }
}
```

5. 层序遍历
   通过依次将左右子树压入队列，

```java
public void LevelorderTraversal(BinTree BT) {
  Queue<BinTree> Q = new Queue<>();
  BinTree T = new BinTree();
  if(BT.empty()) {
    return;
  }
  Q.offer(BT);
  while(T) {
    T = Q.poll();
    System.out.println(T.data);
    if(T.left) {
      Q.offer(T.left);
    }
    if(T.right) {
      Q.offer(T.right);
    }
  }
}

```
