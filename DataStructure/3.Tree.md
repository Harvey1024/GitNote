# 3. Tree

## 3.1 定义

树是 n(n>0) 个结点构成的有限集合，当 n=0 时为空树，对于任意一个非空树，都有以下性质

1. 树中只有一个称为树根 root 的特殊节点，用 r 表示
2. 其余结点可以划分为 m 个不相交的子集 T1, T2, ... Tm, 任何子集 Ti(i 属于[1,m])也是一个树成为根节点的子树 subTree, 每个子树的根结点都与 r 有一条相链接的便，r 是这些子树根结点的父结点 parent

基本术语

1. 结点的度 degree，是子树的个数
2. 树的度，所有结点中最大的度
3. 叶结点 leaf，度为 0 的结点
4. 父节点 parent，具有子树的结点是其子树的根节点的父节点
5. 子节点 child， 某个结点，其子树的根结点是它的子节点
6. 兄弟结点 sibling， 具有相同父结点的各结点彼此是兄弟结点
7. 祖先结点 ancestor, 沿树根到某一结点路径上的所有结点是这个结点的祖先结点
8. 子孙结点 descendant， 某结点的子树中所有的结点是这个结点的子孙
9. 结点的层次 level, 根节点在第一层，其他任意一结点的层数是其父结点的层数+1
10. 树的深度 depth, 所有结点中的最大层次
11. 分支，树中两相邻结点的连边成为一个分支
12. 路径和路径长度，从结点 n1 到 nk 的路径被定义为 n1, n2, ... nk, 路径长度是这条路径上边的个数

## 3.2 二叉树 BinTree

二叉树由根节点和左子树和右子树组成
二叉树性质

1. 第 i 层的最大结点树为`pow(2, i-1)`
2. 二叉树的最大总节点数为`pow(2, k)-1`，其中 k 为总层数
3. 顺序存储第 i 个位置结点的左子树位置为`2*i+1`， 右子树位置为`2*i+2`

### 二叉树的创建

```java

public class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode() {
  }

  TreeNode(int val) {
    this.val = val;
  }

  TreeNode(int val, TreeNode left, TreeNode right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

public class Solution{
  public static void main(String[] args) {
    int[] a = {0, 1, 2, 3, 4};
    TreeNode treeNode = createTree(a);
  }
  public static TreeNode createTree(int[] a) {
    int level = 0;
    double b = 0;
    //求树的层数 level
    while (true) {
      b = Math.pow(2, level) - 1;
      if (a.length <= b) {
        System.out.printf("b: %s %n", String.valueOf(b));
        break;
      }
      level++;
    }
    //从叶结点向上开始创建树
    TreeNode[] trees = new TreeNode[a.length];
    int kk = (int) Math.pow(2, level - 1) - 1;
    while (kk >= 0) {
      for (int i = kk; i < a.length; i++) {
        TreeNode t = new TreeNode();
        t.val = a[i];
        if (2 * i + 1 > a.length - 1) {
          t.left = null;
        } else {
          t.left = trees[2 * i + 1];
        }
        if (2 * i + 2 > a.length - 1) {
          t.right = null;
        } else {
          t.right = trees[2 * i + 2];
        }
        trees[i] = t;
      }
      kk = (int) Math.pow(2, --level - 1) - 1;
    }

    return trees[0];
  }
}
```

### 3.2.1 二叉树的遍历

1. 中序遍历：对任意结点访问是在遍历完左子树后进行的

- 中序遍历其左子树
- 访问根节点
- 中序遍历其右子树

```c++
void InorderTraversal(BinTree BT){
  if(BT) {
    InorderTraversal(BT.Left);
    print("%d", BT.Data);
    IorderTraversal(BT.Right);
  }
}
```

2. 先序遍历

- 访问根节点
- 先序遍历其左子树
- 先序遍历其右子树

```c++
void PreorderTraversal(BinTree BT){
  if(BT) {
    print("%d", BT.Data);
    PreorderTraversal(BT.Left);
    PrerderTraversal(BT.Right);
  }
}
```

3. 后续遍历

- 后续遍历其左子树
- 后续遍历其右子树
- 访问根结点

```c++
void PostorderTraversal(BinTree BT){
  if(BT) {
    PostorderTraversal(BT.Left);
    PostrderTraversal(BT.Right);
    print("%d", BT.Data);
  }
}
```

4. 非递归遍历

```c++
void InorderTraversal(BinTree BT){
  BinTree T;
  Stack S = CreateStacck();
  T = BT;
  while( T || !IsEmpty(S)) {
    while(T) {
      S.push(T);
      T = T.left;
    }
    T = S.pop();
    printf("%d", T.data);
    T = T.right;
  }
}
```

5. 层序遍历
   通过依次将左右子树压入队列，

```java
public static void LevelorderTraversal(TreeNode t) {
  Queue<TreeNode> queue = new LinkedList<>();
  TreeNode treeNode = new TreeNode();
  if (t == null) {
    return;
  }
  queue.offer(t);
  while (!queue.isEmpty()) {
    treeNode = queue.poll();
    System.out.println(treeNode.val);
    if (treeNode.left != null) {
      queue.offer(treeNode.left);
    }
    if (treeNode.right != null) {
      queue.offer(treeNode.right);
    }
  }
}

```

## 例子

### 1. 判断两个树是否相同

输入 a = [1,2,3,4], b = [1,2,3,4]  
输出 true  
采用先序遍历方法：

```java
public class Solution {
    public static boolean isSameTree(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) {
      return true;
    } else if (t1 == null || t2 == null) {
      return false;
    } else if (t1.val != t2.val) {
      return false;
    } else {
      return isSameTree(t1.left, t2.left) && isSameTree(t1.right, t2.right);
    }
  }
}
```
