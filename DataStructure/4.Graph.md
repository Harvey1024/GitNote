## 4. 图

### 4.7 拓扑排序

对有向无环图进行排序，  
排序算法主要指向以下两步：  

1. 选择入度点为0的定点
2. 删除该定点的所有的出边。
![img](https://bkimg.cdn.bcebos.com/pic/adaf2edda3cc7cd9565490a03401213fb80e914a?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1)

如图，映射V1:0, V3: 1, V4: 2, V5: 3, V6: 4, V7: 7  
V1的没有入边，入度为0， V7有3条边，入度为3。  
V1`的父节点是`V3, V4,   
写出入度列表，和出度列表：  
    Indegree = [0, 1, 1, 0, 1, 3]  
    Adj = [[V3, V4], [V6, V7], [V7], [V7], [], []]  

你  
奥德赛      

执行步骤：  

1. 初始化，将入度为0的加入到队列，queue = [V1, V5]，创建输出列表res = []

2. queue将V1出列，查找V1的父节点，V3, V4, 将父节点的入度-1， Indegree = [0, 0, 0, 0, 1, 3]

3. 父节点的入度==0， 加入到队列。queue = [V5, V3, V4 ]

4. queue将V5出列，查找父节点，如此循环。直到列队为空。

```java
public List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {
    List<Integer> res = new ArrayList<>();
    Queue<Integer> queue = new LinkedList<>();
    for(int i = 0; i < n; i++) {
        if(inDegree[i] == 0) {
            queue.offer(i);
        }
    }
    while(!queue.isEmpty()) {
        Integer front = queue.poll();
        res.add(front);
        for(Int sucessor: adj[front]) {
            inDegree[sucessor]--;
            if(inDegree[sucessor] == 0) {
                queue.offer[sucessor];
            }
        }
    }
    if(res.size() == n) {
        return res;
    }
    return new ArrayList<>();
}
```

   