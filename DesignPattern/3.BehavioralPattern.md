# 3. 行为型模式
行为型模式是对在不同的对象之间划分责任和算法的抽象化。
行为型模式分为：
- 类行为型模式：使用继承关系在几个类之间分配行为
- 对象行为型模式：使用对象的聚合关联关系分配行为

## 3.1 命令模式
1. 意图：
请求的发送者和接受者之间完全解耦，二者之间没有之间的引用关系，发送请求的对象只需要如何发送请求，不需要知道如何完成请求。
2. 适用：
    - 抽象待执行动作以参数化某对象。（调用者和请求者解耦）
    - 在不同时刻指定、排列、执行请求
    - 支持撤销操作
    - 支持修改日志，当系统崩溃时这些修改可以重做。
    - 在构建在原语操作上的高层操作构造一个系统，从而提供了对事物进行建模的方法
    - 系统需要将一组操作组合在一起，支持宏命令
3. 实现要点：
定义命令接口，具体的命令类可以决定如何处理请求。

![picture 2](img/1594531803584.png)  
- Command:抽象命令类  
- ConcreteCommand:具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client: 客户类

在调用者和接受者之间增加抽象命令类和命令类，使二者完全解耦。
新的命令可以很容易地加入到系统中。
可以比较容易设计一个命令队里和宏命令（组合命令）
可以方便地实现对请求的undo和redo

## 3.2 中介者模式 Mediator
中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使耦合松散，可以独立地改变他们之间的交互。中介者模式又称为调停者模式。
1. 意图：
一个模块由多个对象组成，对象间存在相互引用，耦合度高。适用中介者模式可以降低耦合。
2. 适用性
    - 对象之间存在复杂的引用关系，产生的相互依赖关系混乱，难以理解
    - 一个对象由于引用了其他很多对象，导致难以复用
    - 通过一个中间类分装多个类中的行为，而又不想生成太多的子类，利用中介者，在中介者中定义对象。
3. 实现要点：
定义中介者和协作者接口，中介者管理所有协作者之间的关系。

![picture 3](img/1594536722741.png)  

对象之间的交互通过中介者实现，降低了对象之间的关系数量。  
中介者承担：
1. 中转作用：对象之间不需要显示地引用
2. 协调作用：中介者根据封装在自身内部的协调逻辑，将同事成员之间的额关系进行分离和封装。

## 3.3 观察者模式 Observer
观察者模式：定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生翻遍时，其相关依赖对象皆得到通知并自动更新。观察者模式又称为Public-subscribe pattern, model-view pattern, source-listener pattern, dependents pattern.

1. 意图：
一个对象发生改变时通知其他对象。
2. 适用：

3. 实现要点：

![picture 4](img/1594541102739.png)  

## 3.4 状态模式
1. 意图：
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
2. 适用性：
    - 对象的行为取决于他的状态，并在运行时根据状态改变行为，
    - 操作中含有**庞大的多分支**的条件语句，且这些分支依赖于该对象的状态。
3. 实现要点：
定义状态接口，具体状态类中实现该状态对应的行为，上下文对象中聚合当前的状态。

例如：

![1594133397904.png](img\1594133397904.png)


封装了转换规则，增加状态只需要增加newState()类，不需要修改State, Content类  
对象content状态改变后时，改变他的行为(content.getState().toString()), 对象content看起来像是修改了类。

- state状态：  
定义了根据不同状态进行不同处理的接口，该接口是那些处理内容依赖的方法集合。
- 具体的状态：  
实现state接口
- context:
持有当前状态的具体实例的实例，还定义了供外部使用者使用的状态模式的接口。

## 3.5 策略模式