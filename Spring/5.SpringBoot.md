# 5. Spring Boot
1. Spring Boot Basic
- @Configuration类  
   建议primary source是单个@Configuration类，通常main方法的类是primary @Configuration
- 导入Configuration类  
   不用把所有的@Configuration放在一个类，可以放在不同的类，用@Import导入, 也可以用@ComponentScan自动扫描  
- 自动配置  
   在@Configuration类上加上@SpringBootApplication或@EnableAutoConfiguration启动自动配置，建议加在primary @Configuration上
- 禁用个别类的自动配置  
   @SpringBootApplication(exclude={DataSourceAutoConfiguration.class})  
- 依赖注入  
   将@SpringBootApplication放在根目录root package，其他类加上package，这样使用@ComponentScan，不用带参数,其他所有的Component都会自动注册为Spring Beans  
   使用@AutoWired自动装配
- @SpringBootApplication包含了一下功能
   - @EnableAutoConfiguration
   - @ComponentScan 扫描
   - @Configuration 用于注册额外的bean及导入其他的@Configuration
- Starters
   - 通过一些starters依赖，可以获得所有需要的依赖，不用拷贝各种依赖。
   - starters包含以很多部署一个项目需要的依赖，常用的starters:
      - spring-boot-starter 核心starter，包含自动配置，loggin和YAML
      - spring-boot-starter-aop 支持Spring AOP, AspetJ
      - spring-boot-starter-cache 支持Spring framework的caching
      - spring-boot-starter-data-jpa 支持Spring Data JPA with Hibernate
      - spring-boot-starter-mongodb 支持使用mongodb数据库
      - spring-boot-starter-redis 支持使用redis数据库
      - spring-boot-starter-jdbc 支持使用JDBC with the HikariCP connection pool
      - spring-boot-starter-web 支持创建web, 使用Spring MVC的应用，使用Tomcat作为默认的容器

# 2. Spring Boot Features
## 2.1 SpringApplication
1. 使用  
    通过在main()函数内调用SpringApplication.run(MySpringApplication.class)静态方法bootstrap一个Spring应用。  
2. Logging  
    默认显示INFO logging信息，可以自定义logging级别  
3. 启动异常  
    启动错误时，注册的FailureAnalyzer会提供建议信息和建议的action, 如果FailureAnalyzer不能处理，可以使用 --debug:  
    `java -jar myproject.jar --debug`  
4. Lazy初始化  
    Lazy初始化，Bean是在使用到的时候初始化，而不是启动时初始化，lazy初始化会加快启动速度，但会延迟问题暴露时间，可以在properties文件配置  
    `spring.main.lazy-initialization=true`  
5. 应用状态  
    部署到一些平台上时，Spring会提供可用性信息，也可以注入`ApplicationAvailability`接口到bean里获取可用性状态，两个可用性状态：  
    - Liveness state, 表明内部状态是否能够支持应用正确运行，或者失败后自动恢复。Spring Boot应用程序的内部状态主要由ApplicatonContext表示
    - Readiness state, 表明应用是否准备好处理流量
    - 获取状态, 当Readiness状态是ACCEPTING_TRAFFIC时执行某些操作，当为REFUSING_TRAFFIC时其他操作。
        ```java
        @EventLinstener
        public void onStateChange(AvailableityChangeEvent<ReadinessState> event) {
            switch(event.getState()) {
                case ACCEPTING_TRAFFIC:
                    //create file /tmp/health;
                break;
                case REFUSING_TRAFFIC:
                    //delete file /tmp/health;
                break;
            }
        }
        ```
    - 发布状态，如当缓存出现异常时，需要将Liveness状态改成BROKEN
        ```java
        @Component
        public class LocalCacheVerifier{
            private final ApplicationEventPublisher eventPublisher;
            public LocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
                this.eventPublisher = eventPublisher;
            }

            public void checkLocalCache(){
                try{}
                catch(CacheCompletelyBrokenException ex) {
                    AvailableityChangeEvent.public(this.eventPublisher, ex, LivenessState.BROKEN);
                }
            }
        }
        ```
6. Application Events and Listeners  
    在ApplicationContext创建前触发的事件，不能直接在这些Bean上注册一个Listener, 需要使用SpringApplication.addListeners()注册，或者使用SpringApplicationBuilder.listeners()注册
    发布到子Context的Listener上的事件也会被发送到父Context
7. Web环境  
    SpringApplication会自动检测并选择应该创建哪一种的ApplicationContext  
    如果使用了Spring MVC，则创建AnnotationConfigServletWebServerApplicationContext,  
    如果没用Spring MVC, 使用了Spring WebFlux, 则创建AnnotationConfigReativeWebServerApplication。  
    通过使用`setApplicationContextClass()`指定使用哪种ApplicationContext  
    通常在JUnit测试时使用SpringApplication时设置`setWebApplicationType(WebApplicatonType.NONE)`
    
## 2.2 外部配置

同一目录下同时有.properties 文件和 yml 文件，properties 文件优先
