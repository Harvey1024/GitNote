# 5. Spring Boot
1. Spring Boot Basic
- @Configuration类  
   建议primary source是单个@Configuration类，通常main方法的类是primary @Configuration
- 导入Configuration类  
   不用把所有的@Configuration放在一个类，可以放在不同的类，用@Import导入, 也可以用@ComponentScan自动扫描  
- 自动配置  
   在@Configuration类上加上@SpringBootApplication或@EnableAutoConfiguration启动自动配置，建议加在primary @Configuration上
- 禁用个别类的自动配置  
   @SpringBootApplication(exclude={DataSourceAutoConfiguration.class})  
- 依赖注入  
   将@SpringBootApplication放在根目录root package，其他类加上package，这样使用@ComponentScan，不用带参数,其他所有的Component都会自动注册为Spring Beans  
   使用@AutoWired自动装配
- @SpringBootApplication包含了一下功能
   - @EnableAutoConfiguration
   - @ComponentScan 扫描
   - @Configuration 用于注册额外的bean及导入其他的@Configuration
- Starters
   - 通过一些starters依赖，可以获得所有需要的依赖，不用拷贝各种依赖。
   - starters包含以很多部署一个项目需要的依赖，常用的starters:
      - spring-boot-starter 核心starter，包含自动配置，loggin和YAML
      - spring-boot-starter-aop 支持Spring AOP, AspetJ
      - spring-boot-starter-cache 支持Spring framework的caching
      - spring-boot-starter-data-jpa 支持Spring Data JPA with Hibernate
      - spring-boot-starter-mongodb 支持使用mongodb数据库
      - spring-boot-starter-redis 支持使用redis数据库
      - spring-boot-starter-jdbc 支持使用JDBC with the HikariCP connection pool
      - spring-boot-starter-web 支持创建web, 使用Spring MVC的应用，使用Tomcat作为默认的容器

# 2. Spring Boot Features
## 2.1 SpringApplication
1. 使用  
    通过在main()函数内调用SpringApplication.run(MySpringApplication.class)静态方法bootstrap一个Spring应用。  
2. Logging  
    默认显示INFO logging信息，可以自定义logging级别  
3. 启动异常  
    启动错误时，注册的FailureAnalyzer会提供建议信息和建议的action, 如果FailureAnalyzer不能处理，可以使用 --debug:  
    `java -jar myproject.jar --debug`  
4. Lazy初始化  
    Lazy初始化，Bean是在使用到的时候初始化，而不是启动时初始化，lazy初始化会加快启动速度，但会延迟问题暴露时间，可以在properties文件配置  
    `spring.main.lazy-initialization=true`  
5. 应用状态  
    部署到一些平台上时，Spring会提供可用性信息，也可以注入`ApplicationAvailability`接口到bean里获取可用性状态，两个可用性状态：  
    - Liveness state, 表明内部状态是否能够支持应用正确运行，或者失败后自动恢复。Spring Boot应用程序的内部状态主要由ApplicatonContext表示
    - Readiness state, 表明应用是否准备好处理流量
    - 获取状态, 当Readiness状态是ACCEPTING_TRAFFIC时执行某些操作，当为REFUSING_TRAFFIC时其他操作。
        ```java
        @EventLinstener
        public void onStateChange(AvailableityChangeEvent<ReadinessState> event) {
            switch(event.getState()) {
                case ACCEPTING_TRAFFIC:
                    //create file /tmp/health;
                break;
                case REFUSING_TRAFFIC:
                    //delete file /tmp/health;
                break;
            }
        }
        ```
    - 发布状态，如当缓存出现异常时，需要将Liveness状态改成BROKEN
        ```java
        @Component
        public class LocalCacheVerifier{
            private final ApplicationEventPublisher eventPublisher;
            public LocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
                this.eventPublisher = eventPublisher;
            }

            public void checkLocalCache(){
                try{}
                catch(CacheCompletelyBrokenException ex) {
                    AvailableityChangeEvent.public(this.eventPublisher, ex, LivenessState.BROKEN);
                }
            }
        }
        ```
6. Application Events and Listeners  
    在ApplicationContext创建前触发的事件，不能直接在这些Bean上注册一个Listener, 需要使用SpringApplication.addListeners()注册，或者使用SpringApplicationBuilder.listeners()注册
    发布到子Context的Listener上的事件也会被发送到父Context
7. Web环境  
    SpringApplication会自动检测并选择应该创建哪一种的ApplicationContext  
    如果使用了Spring MVC，则创建AnnotationConfigServletWebServerApplicationContext,  
    如果没用Spring MVC, 使用了Spring WebFlux, 则创建AnnotationConfigReativeWebServerApplication。  
    通过使用`setApplicationContextClass()`指定使用哪种ApplicationContext  
    通常在JUnit测试时使用SpringApplication时设置`setWebApplicationType(WebApplicatonType.NONE)`
8. ApplicationRunner / CommanderLineRunner  
    通过实现ApplicationRunner/CommanderLinerRunner接口，重写run()方法，这时在SpringApplication启动后，且在SpringApplication.run()完成之前执行。
9. 应用关闭  
    当SpringApplication关闭后，所有的标准Spring生命周期回调(DiposableBean/@PreDestory)会被执行。
## 2.2 外部配置
PropertySource的顺序如下，后面的文件会覆盖前面的文件内的同名属性  
- 默认属性
- 在@Configuration上用@PropertySource注解的地址
- 配置文件 如 application.properties
- 命令行参数
- @TestPropertySource

配置文件按照以下顺序：
- 在jar文件内部打包的Application properties(application.properties/.yml)
- 在jar文件内打包的特定的配置文件(application-{profile}.properties/.yml)
- 在jar包外部的Application properties
- 在jar包外部的Profile-special application properties

同一目录下同时有.properties 文件和 yml 文件时，properties 文件优先

Spring Boot安装以下顺序查找application.properties/.yaml
- the classpath root
- The classpath /config path
- The current directory
- The /config subdirectory in the current directory
- Immediate child directories of the /config subdirectory

当需要使用多个property值时，使用@Value效率不高，可以使用@ConfigurationProperties()创建一个类，和对应的property形成映射关系，属性是变量  
需要定义setter, getter方法，但不能定义构造函数，容器会自动实例化这个对象。
使用@ConstructorBinding加上@ConfigurationProperties注解，绑定自定义的构造函数，属性均是常量。
## 2.3 Profiles
使配置分离，使多个配置仅在特定的环境下生效。  
任意的@Component, @Configuration, @ConfigurationProperties可以使用@Profile限定范围，如`@Profile("production")`  
使用`spring.profiles.active=dev,hsqldb`限定哪个prifile是激活的  
### Profile Groups
如果需要两个不同的profile独立地工作，可以使用profile gruop
```yaml
spring:
    profiles:
        group:
        - "proddb"
        - "prodmq"
```
## 2.4 Logging
