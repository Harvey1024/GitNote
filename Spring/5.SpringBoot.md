# 5. Spring Boot

1. Spring Boot Basic

- @Configuration 类  
   建议 primary source 是单个@Configuration 类，通常 main 方法的类是 primary @Configuration
- 导入 Configuration 类  
   不用把所有的@Configuration 放在一个类，可以放在不同的类，用@Import 导入, 也可以用@ComponentScan 自动扫描
- 自动配置  
   在@Configuration 类上加上@SpringBootApplication 或@EnableAutoConfiguration 启动自动配置，建议加在 primary @Configuration 上
- 禁用个别类的自动配置  
   @SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
- 依赖注入  
   将@SpringBootApplication 放在根目录 root package，其他类加上 package，这样使用@ComponentScan，不用带参数,其他所有的 Component 都会自动注册为 Spring Beans  
   使用@AutoWired 自动装配
- @SpringBootApplication 包含了一下功能
  - @EnableAutoConfiguration
  - @ComponentScan 扫描
  - @Configuration 用于注册额外的 bean 及导入其他的@Configuration
- Starters
  - 通过一些 starters 依赖，可以获得所有需要的依赖，不用拷贝各种依赖。
  - starters 包含以很多部署一个项目需要的依赖，常用的 starters:
    - spring-boot-starter 核心 starter，包含自动配置，loggin 和 YAML
    - spring-boot-starter-aop 支持 Spring AOP, AspetJ
    - spring-boot-starter-cache 支持 Spring framework 的 caching
    - spring-boot-starter-data-jpa 支持 Spring Data JPA with Hibernate
    - spring-boot-starter-mongodb 支持使用 mongodb 数据库
    - spring-boot-starter-redis 支持使用 redis 数据库
    - spring-boot-starter-jdbc 支持使用 JDBC with the HikariCP connection pool
    - spring-boot-starter-web 支持创建 web, 使用 Spring MVC 的应用，使用 Tomcat 作为默认的容器

# 2. Spring Boot Features

## 2.1 SpringApplication

1. 使用  
   通过在 main()函数内调用 SpringApplication.run(MySpringApplication.class)静态方法 bootstrap 一个 Spring 应用。
2. Logging  
   默认显示 INFO logging 信息，可以自定义 logging 级别
3. 启动异常  
   启动错误时，注册的 FailureAnalyzer 会提供建议信息和建议的 action, 如果 FailureAnalyzer 不能处理，可以使用 --debug:  
   `java -jar myproject.jar --debug`
4. Lazy 初始化  
   Lazy 初始化，Bean 是在使用到的时候初始化，而不是启动时初始化，lazy 初始化会加快启动速度，但会延迟问题暴露时间，可以在 properties 文件配置  
   `spring.main.lazy-initialization=true`
5. 应用状态  
   部署到一些平台上时，Spring 会提供可用性信息，也可以注入`ApplicationAvailability`接口到 bean 里获取可用性状态，两个可用性状态：

   - Liveness state, 表明内部状态是否能够支持应用正确运行，或者失败后自动恢复。Spring Boot 应用程序的内部状态主要由 ApplicatonContext 表示
   - Readiness state, 表明应用是否准备好处理流量
   - 获取状态, 当 Readiness 状态是 ACCEPTING_TRAFFIC 时执行某些操作，当为 REFUSING_TRAFFIC 时其他操作。
     ```java
     @EventLinstener
     public void onStateChange(AvailableityChangeEvent<ReadinessState> event) {
         switch(event.getState()) {
             case ACCEPTING_TRAFFIC:
                 //create file /tmp/health;
             break;
             case REFUSING_TRAFFIC:
                 //delete file /tmp/health;
             break;
         }
     }
     ```
   - 发布状态，如当缓存出现异常时，需要将 Liveness 状态改成 BROKEN

     ```java
     @Component
     public class LocalCacheVerifier{
         private final ApplicationEventPublisher eventPublisher;
         public LocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
             this.eventPublisher = eventPublisher;
         }

         public void checkLocalCache(){
             try{}
             catch(CacheCompletelyBrokenException ex) {
                 AvailableityChangeEvent.public(this.eventPublisher, ex, LivenessState.BROKEN);
             }
         }
     }
     ```

6. Application Events and Listeners  
   在 ApplicationContext 创建前触发的事件，不能直接在这些 Bean 上注册一个 Listener, 需要使用 SpringApplication.addListeners()注册，或者使用 SpringApplicationBuilder.listeners()注册
   发布到子 Context 的 Listener 上的事件也会被发送到父 Context
7. Web 环境  
   SpringApplication 会自动检测并选择应该创建哪一种的 ApplicationContext  
   如果使用了 Spring MVC，则创建 AnnotationConfigServletWebServerApplicationContext,  
   如果没用 Spring MVC, 使用了 Spring WebFlux, 则创建 AnnotationConfigReativeWebServerApplication。  
   通过使用`setApplicationContextClass()`指定使用哪种 ApplicationContext  
   通常在 JUnit 测试时使用 SpringApplication 时设置`setWebApplicationType(WebApplicatonType.NONE)`
8. ApplicationRunner / CommanderLineRunner  
   通过实现 ApplicationRunner/CommanderLinerRunner 接口，重写 run()方法，这时在 SpringApplication 启动后，且在 SpringApplication.run()完成之前执行。
9. 应用关闭  
   当 SpringApplication 关闭后，所有的标准 Spring 生命周期回调(DiposableBean/@PreDestory)会被执行。

## 2.2 外部配置

PropertySource 的顺序如下，后面的文件会覆盖前面的文件内的同名属性

- 默认属性
- 在@Configuration 上用@PropertySource 注解的地址
- 配置文件 如 application.properties
- 命令行参数
- @TestPropertySource

配置文件按照以下顺序：

- 在 jar 文件内部打包的 Application properties(application.properties/.yml)
- 在 jar 文件内打包的特定的配置文件(application-{profile}.properties/.yml)
- 在 jar 包外部的 Application properties
- 在 jar 包外部的 Profile-special application properties

同一目录下同时有.properties 文件和 yml 文件时，properties 文件优先

Spring Boot 安装以下顺序查找 application.properties/.yaml

- the classpath root
- The classpath /config path
- The current directory
- The /config subdirectory in the current directory
- Immediate child directories of the /config subdirectory

当需要使用多个 property 值时，使用@Value 效率不高，可以使用@ConfigurationProperties()创建一个类，和对应的 property 形成映射关系，属性是变量  
需要定义 setter, getter 方法，但不能定义构造函数，容器会自动实例化这个对象。
使用@ConstructorBinding 加上@ConfigurationProperties 注解，绑定自定义的构造函数，属性均是常量。

## 2.3 Profiles

使配置分离，使多个配置仅在特定的环境下生效。  
任意的@Component, @Configuration, @ConfigurationProperties 可以使用@Profile 限定范围，如`@Profile("production")`  
使用`spring.profiles.active=dev,hsqldb`限定哪个 prifile 是激活的

### Profile Groups

如果需要两个不同的 profile 独立地工作，可以使用 profile gruop

```yaml
spring:
  profiles:
    group:
      - "proddb"
      - "prodmq"
```

## 2.4 Logging

## Redis

## MyBatis

- MyBatis 是一个持久化框架
- 支持定制化 SQL,存储过程和高级映射

使用过程：

1. 配置 mybatis 依赖
2. 配置 xml
   - 配置数据源 DataSource
   - 事务的作用域及事务管理器 TransactionManager
   - mapper，包含 sql 代码和映射定义信息
3. 读取 xml 文件为 InputStream, 用 SqlSessionFactoryBuilder 获得一个 SqlSessionFactory
4. 从 SqlSessionFactory 打开一个 Session, 从 Session 获得一个 mapper(传入 mapper 的 Class 实例)
5. 执行 mapper 内定义的方法

- SqlSessionFactoryBuilder 是用于获得 SqlSessonFactory 的工厂，使用后就可以丢弃
- SqlSessionFactory 生产 SqlSession 需要重复使用，需要一直存在，使用 Singleton 类型，
- SqlSession 生产 Mapper, 用于用于执行映射的语句，提交和回滚，不需要的时候可以关闭。它不是线程安全的，所以需要 SqlSessionFactory 多次生产 SqlSession

示例：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
<select id="selectBlog" resultType="Blog">
   select * from Blog where id = #{id}
</select>
</mapper>
```

```java
// 读取配置，获得SqlSessionFactory 实例
String resource = "org/mybatis/example/mybatis-config.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
// 数据库操作
try (SqlSession session = sqlSessionFactory.openSession()) {
BlogMapper mapper = session.getMapper(BlogMapper.class);
Blog blog = mapper.selectBlog(101);
}
```

使用映射器  
 使用 session.insert()或 session.update()等操作不符合类型安全，因此推荐使用映射器类，映射器类就是一个仅声明与 SqlSession 方法相匹配的接口。

```java
// 定义一个接口，和xml语句对应，可以通过依赖注入获得BlogMapper的实例
package org.mybatis.example;
public interface BlogMapper {
Blog selectBlog(int id);
}
```

## Mybatis-Spring Boot

mybatis-spring-boot-starter 实现了自动化配置，使能够快速搭建应用

- 自动检测已经注册了的 DataSource
- 通过 SqlSessionFactoryBean 传入 DataSource 作为参数创建 SqlSessionFactory 实例
- 通过 SqlSessionFactory 创建 SqlSessionTemplate 实例
- 自动扫描 mapper, 将他们连接到 SqlSessionTemplate
- 创建实现了下面接口的 Bean

  - Interceptor
  - TypeHandler 每当在和数据库交互时处理对象的属性时，都会检测类型，实现 java 类型到 JDBC 类型之间的转换，可以通过实现 BaseTyperHandler 接口或 TypeHandler 接口自定义转换
  - LanguageDriver
  - DatabaseIdProvider
    Spring Boot 自动创建了 SqlSessionFactory bean, 及 SqlSessionTemplate bean, 并将这两个 Bean 注入到自己定义的 Mapper bean 中。

- SqlSessionTemplate
  - 是 MyBatis-Spring 的核心，是 SqlSession 的实现，是线程安全的，所以被共享，所以不用多次用 SqlSessionFactory 生产 Session。
  - SqlSessionTemplate 会保证使用的 SqlSession 与当前的事务相关，它管理着 session 的生命周期，包含关闭，提交，回滚操作。
  - 负责将 MyBatic 异常翻译成 Spring 中的 DataAccessException
- @MapperScan 在@Configuration 类上设置，会自动扫描注册 Mapper

注解

- @Option 填入将 mybatis.configuration 下的配置，说明当前方法的配置

配置 `mybatis.`

- config-location : MyBatis 配置 xml 文件地址
- type-handlers-package
- `configuration.*` :属性设置，注意和用 xml 配置不能同时使用
  - userGeneratedKeys 支持生产 generated key, 默认 false
  - mapUnderscoreToCamelCase 自动映射下划线到驼峰名，默认 false
- configuration-properties 扩展配置
